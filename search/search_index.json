{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to postbp","text":"<p>A Python Library</p> <p>PostBP is an open-source Python package designed for post-processing the raw outputs of fire growth models \u2014 the ignition locations and perimeters of individual fires simulated over multiple stochastic iterations \u2014 into a matrix of fire spread likelihoods between all pairs of forest patches in a landscape. </p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://nliu-cfs.github.io/postbp</li> </ul>"},{"location":"#features","title":"Features","text":"<p>PostBP offers three post-processing options for analyzing FGM outputs.  - Option 1 (\u201cDirect overlay analysis\u201d) generates maps of mean burn and ignition likelihoods for a user-defined set of forest landscape patches.   - Option 2 (\u201cDirectional fire spread analysis\u201d) uses the ignition locations and final perimeters of individual fires to generate vectors of spread likelihoods between all pairs of forest patches in a landscape, along with a map of source-sink ratios and a fire spread rose diagram.   - Option 3 (\u201cDaily directional fire spread analysis\u201d) is similar to option 2 but generates fire spread likelihoods and summary outputs from sequences of daily fire perimeters instead of the final fire perimeters utilized in option 2.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#postbp.common.pij_to_shp","title":"<code>pij_to_shp(pij_input, nodes, **kwargs)</code>","text":"<p>Adding geometry to pij vectors file</p> <p>Parameters:</p> Name Type Description Default <code>pij_input</code> <code>DataFrame</code> <p>pij dataframe</p> required <code>nodes</code> <code>GeoDataFrame</code> <p>centroid of the hexagonal patches</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>pij value with geometry of lines connecting node-i and node-j</p> Source code in <code>postbp/common.py</code> <pre><code>def pij_to_shp(pij_input, nodes, **kwargs):\n    \"\"\"Adding geometry to pij vectors file\n\n    Args:\n        pij_input (DataFrame): pij dataframe\n        nodes (GeoDataFrame): centroid of the hexagonal patches\n\n    Returns:\n        GeoDataFrame: pij value with geometry of lines connecting node-i and node-j\n    \"\"\"    \n\n    pij = pij_input.copy()\n    node = nodes.copy()\n    if 'Node_ID' in kwargs:\n        node = node.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n    if 'column_i' in kwargs:\n        pij.rename(columns={kwargs[\"column_i\"]: 'column_i'}, inplace=True)    \n    if 'column_j' in kwargs:\n        pij.rename(columns={kwargs[\"column_j\"]: 'column_j'}, inplace=True)           \n\n    SRID = node.crs\n    pij = node.merge(pij, left_on='Node_ID', right_on='column_i', how='right')\n    pij = pij.merge(node, left_on='column_j', right_on='Node_ID', how='left')\n    pijLine = [LineString(xy) for xy in zip(pij['geometry_x'], pij['geometry_y'])]\n    pijshp = gpd.GeoDataFrame(pij, crs = SRID, geometry = pijLine )\n    pijshp.drop(labels = ['geometry_x', 'geometry_y', 'Node_ID_x', 'Node_ID_y'], axis = 1, inplace = True)\n    return pijshp\n</code></pre>"},{"location":"common/#postbp.common.prj2hex","title":"<code>prj2hex(shp0, hexagons, threshold=0)</code>","text":"<p>Generate a geometric intersection of shp0 and the hexagon shapefile. option to set threshold</p> <p>Parameters:</p> Name Type Description Default <code>shp0</code> <code>GeoDataFrame</code> <p>GeoDataFrame to be identified by hexagon shape</p> required <code>hexagons</code> <code>GeoDataFrame</code> <p>hexagonal patches</p> required <code>threshold</code> <code>float</code> <p>Value between 0 and 1. The proportion for classifying hexagon as intersecting with shp0. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>Return a GeoDataFrame of the intersection with hexagon ID field as attributes</p> Source code in <code>postbp/common.py</code> <pre><code>def prj2hex(shp0, hexagons, threshold=0):\n    \"\"\"Generate a geometric intersection of shp0 and the hexagon shapefile.\n    option to set threshold\n\n    Args:\n        shp0 (GeoDataFrame): GeoDataFrame to be identified by hexagon shape\n        hexagons (GeoDataFrame): hexagonal patches\n        threshold (float, optional): Value between 0 and 1. The proportion for classifying hexagon as intersecting with shp0. Defaults to 0.\n\n    Returns:\n        GeoDataFrame: Return a GeoDataFrame of the intersection with hexagon ID field as attributes\n    \"\"\"    \n    thresholdArea = hexagons.at[1,'geometry'].area * threshold\n    try:\n        shp1 = gpd.overlay(shp0, hexagons, how='intersection') \n    except:\n        pass    \n    shp1['areaFire'] = shp1.geometry.area\n    shp1 = shp1.loc[shp1['areaFire'] &gt; thresholdArea]\n    shp1.drop(labels='areaFire', axis=1, inplace=True)\n    return shp1\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/nliu-cfs/postbp/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>postbp could always use more documentation, whether as part of the official postbp docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/nliu-cfs/postbp/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up postbp for local development.</p> <ol> <li> <p>Fork the postbp repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/postbp.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv postbp\n$ cd postbp/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 postbp tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/nliu-cfs/postbp/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"dailyfirevectors/","title":"dailyfirevectors module","text":"<p>Module to processing daily progression of fire</p>"},{"location":"dailyfirevectors/#postbp.dailyfirevectors.angle","title":"<code>angle(record)</code>","text":"<p>Calculate angle from three points: ignition point and the points where fire spread from and to.  </p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>dataframe</code> <p>a row of the output from generate_daily_vectors function</p> required <p>Returns:</p> Type Description <code>degree value</code> <p>the value of beta angle, i.e. the angle between the line connecting ignition point and starting point of fire, and the line connecting the hexagon nodes that a fire spreading from and to. </p> Source code in <code>postbp/dailyfirevectors.py</code> <pre><code>def angle(record):\n    \"\"\"Calculate angle from three points: ignition point and the points where fire spread from and to.  \n\n    Args:\n        record (dataframe): a row of the output from generate_daily_vectors function\n\n    Returns:\n        degree value: the value of beta angle, i.e. the angle between the line connecting ignition point and starting point of fire, and the line connecting the hexagon nodes that a fire spreading from and to. \n    \"\"\"    \n    x0, y0 = record['geometry_x'].x, record['geometry_x'].y\n    x1, y1 = record['geometry'].x, record['geometry'].y\n    x2, y2 = record['geometry_y'].x, record['geometry_y'].y\n    xv1, yv1 = x1-x0, y1-y0\n    xv2, yv2 = x2-x0, y2-y0\n    deg1 = (360 + degrees(atan2(xv1, yv1))) % 360\n    deg2 = (360 + degrees(atan2(xv2, yv2))) % 360\n    return deg2 - deg1 if deg1 &lt;= deg2 else 360 - (deg1 - deg2)\n</code></pre>"},{"location":"dailyfirevectors/#postbp.dailyfirevectors.calc_angles","title":"<code>calc_angles(vectors, nodes, **kwargs)</code>","text":"<p>Calculate beta angle for every pair of vectors of fire spread</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>dataframe</code> <p>outputs from generate_daily_vectors function</p> required <code>nodes</code> <code>GeoDataFrame</code> <p>centroid points of the hexagonal patch network</p> required <p>Returns:</p> Type Description <code>dataframe</code> <p>a dataframe containing geometry of i, j, ignition point and beta angle value of each vector</p> Source code in <code>postbp/dailyfirevectors.py</code> <pre><code>def calc_angles(vectors, nodes, **kwargs):\n    \"\"\"Calculate beta angle for every pair of vectors of fire spread\n\n    Args:\n        vectors (dataframe): outputs from generate_daily_vectors function\n        nodes (GeoDataFrame): centroid points of the hexagonal patch network\n\n    Returns:\n        dataframe: a dataframe containing geometry of i, j, ignition point and beta angle value of each vector\n    \"\"\"    \n    node = nodes.copy()\n    if 'Node_ID' in kwargs:\n        node = node.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n\n    vectorsW = vectors.copy()\n    vectorsW = node.merge(vectors, left_on='Node_ID', right_on='column_i', how='right')\n    vectorsW = vectorsW.merge(node, left_on='column_j', right_on='Node_ID', how='left')\n    vectorsW = vectorsW.merge(node, left_on='ignPt', right_on='Node_ID', how='left')\n    vectorsW.drop(labels = ['Node_ID_x', 'Node_ID_y', 'Node_ID'], axis = 1, inplace = True)\n\n    #### note that 'geometry_x':origin; 'geometry_y':destination; 'geometry':ignition\n\n    for index, row in tqdm(vectorsW.iterrows()):\n        try: \n            vectorsW.at[index, 'angle'] = angle(row)\n        except:\n            vectorsW.at[index, 'angle'] = 181  # when origin is identical to ignition\n    vectorsW.loc[vectorsW['day'] == 999, 'angle'] = 361  # from ignition to all hexes in perimeter\n    vectorsW.loc[vectorsW['day'] == 1, 'angle'] = 181  # in day 1: origin is identical to ignition\n    vectorsW.drop_duplicates(subset = ['day', 'column_j', 'fire', 'ignPt', 'column_i'], keep = 'first', inplace = True)\n    return vectorsW\n</code></pre>"},{"location":"dailyfirevectors/#postbp.dailyfirevectors.generate_daily_vectors","title":"<code>generate_daily_vectors(fireshp, ignition, hexagons, bufferFactor=10, **kwargs)</code>","text":"<p>Generate fire spreading vectors from the daily fire spread perimeters</p> <pre><code>!!! args\n    fireshp (GeoDataFrame): the daily fire perimeter geometry with fire ID and day of spread as attributes\n    ignition (GeoDataFrame): ignition point shapes with fire ID field in attributes\n    hexagons (GeoDataFrame): geometry of hexagonal patches with ID field\n    bufferFactor (int, optional): convert ignition point into a circle polygon of the diameter of bufferFactor\n</code></pre> <p>it shall be small enough so as not to have ignition point locates in more than one hexagons it also defines threshold for the minimum area of fire perimeter to be in a hexagon to be regarded as burned. Defaults to 10.</p> <pre><code>!!! returns\n    DataFrame: a dataframe table containing fire starting hexagon ID (i), destination hexagon ID (j), 'day', fire ID, and ignition hexagon ID\n</code></pre> Source code in <code>postbp/dailyfirevectors.py</code> <pre><code>def generate_daily_vectors(fireshp, ignition, hexagons, bufferFactor=10, **kwargs):\n    \"\"\"Generate fire spreading vectors from the daily fire spread perimeters\n\n    Args:\n        fireshp (GeoDataFrame): the daily fire perimeter geometry with fire ID and day of spread as attributes\n        ignition (GeoDataFrame): ignition point shapes with fire ID field in attributes\n        hexagons (GeoDataFrame): geometry of hexagonal patches with ID field\n        bufferFactor (int, optional): convert ignition point into a circle polygon of the diameter of bufferFactor\nit shall be small enough so as not to have ignition point locates in more than one hexagons it also defines threshold for the minimum area of fire perimeter to be in a hexagon to be regarded as burned. Defaults to 10.\n\n    Returns:\n        DataFrame: a dataframe table containing fire starting hexagon ID (i), destination hexagon ID (j), 'day', fire ID, and ignition hexagon ID \n    \"\"\"    \n    hexagon = hexagons.copy()\n    if 'Node_ID' in kwargs:\n        hexagon = hexagon.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n\n    threshold = 3.1415926*bufferFactor**2 - 1 \n    SRID = fireshp.crs\n    df = pd.DataFrame()\n    dfMore = pd.DataFrame()\n\n    for i in tqdm(np.unique(fireshp['fire'])):\n        try: \n            fire_i = fireshp.loc[fireshp['fire'] == i]\n            pts_i = ignition.loc[ignition['fire'] == i]\n            pts_ni = gpd.sjoin(pts_i, hexagon, how = 'inner', op = 'within')\n            ##### ignition point to all hexes\n            dmax = max(fire_i['day'])\n            fire_idmax = fire_i.loc[fire_i['day'] == dmax]\n            dfDmax = prj2hex(fire_idmax, hexagon, threshold)\n            dfMore = pd.DataFrame([e for e in itertools.product(pts_ni['Node_ID'], dfDmax['Node_ID'])], columns=['column_i', 'column_j'])\n            # from ignition point to all other hexes in the fire perimeters (as regular fire vectors) are stored by day=999\n            dfMore['day'] = 999       \n            dfMore.drop(dfMore.loc[dfMore['column_i'] == dfMore['column_j']].index, inplace = True)\n            #### leading edge\n            leadEdge = list(pts_ni['Node_ID'])\n            shpDB4 = gpd.GeoDataFrame(crs = SRID, geometry = pts_i.buffer(bufferFactor))\n            for d in range(1, max(fire_i['day'])+1):\n                fire_id = fire_i.loc[fire_i['day'] == d]\n                fire_idn = prj2hex(fire_id, hexagon, threshold)\n                ## hexagons in the fireshed of previous day\n                lstDB4 = prj2hex(shpDB4, hexagon, threshold)\n                lstDB4 = list(lstDB4['Node_ID'])\n                ## hexagons to be spread\n                listCur = list(fire_idn.loc[~fire_idn['Node_ID'].isin(lstDB4)]['Node_ID'])\n                #### consider when two days spread overlap in hexagon projections, hence listCur is empty\n                if listCur:\n                    dfTemp = pd.DataFrame([e for e in itertools.product(leadEdge, listCur)], columns = ['column_i', 'column_j'])\n                    dfTemp['day'] = d\n                else:\n                    dfTemp = pd.DataFrame()\n                dfMore = pd.concat([dfMore, dfTemp])  #, sort = False\n                dfMore.drop_duplicates(subset = ['column_i', 'column_j', 'day'], keep = 'first', inplace = True)\n                #### update fireshed shape by merging fireshed of t with t-1\n                shpDB4 = fire_id.copy()\n                shpEx = gpd.GeoDataFrame(crs = SRID, geometry = shpDB4.exterior.buffer(1))\n                shpExHex = prj2hex(shpEx, hexagon, threshold = 0)\n                leadEdgeC = list(shpExHex['Node_ID'])\n                leadEdgeN = [x for x in leadEdgeC if x not in lstDB4]\n                if leadEdgeN:\n                    leadEdge = leadEdgeN\n                else:\n                    pass\n            dfMore = dfMore.reset_index(drop = True)\n            dfMore.drop_duplicates(subset = ['column_i', 'column_j', 'day'], keep = 'first', inplace = True)\n            dfMore['fire'] = i\n            dfMore['ignPt'] = pts_ni['Node_ID'].item()\n            df = pd.concat([df, dfMore], sort = True)\n        except Exception as e:\n            with open(\"errorlog_dailyfire.txt\", \"w+\") as f:\n                f.write(f'{e} occurs for fire ID # {i} \\n')    \n    return df\n</code></pre>"},{"location":"dailyfirevectors/#postbp.dailyfirevectors.select_angle","title":"<code>select_angle(vectors_with_angle, alpha)</code>","text":"<p>Select intended angle of fire spread sector</p> <p>Parameters:</p> Name Type Description Default <code>vectors_with_angle</code> <code>dataframe</code> <p>outputs from calc_angles function</p> required <code>alpha</code> <code>degree</code> <p>fire spread sector angle (alpha angle), value from 0 to 360</p> required <p>Returns:</p> Type Description <code>dataframe</code> <p>a dataframe containing geometry of i, j, ignition point and beta angle value of each vector</p> Source code in <code>postbp/dailyfirevectors.py</code> <pre><code>def select_angle(vectors_with_angle, alpha):\n    \"\"\"Select intended angle of fire spread sector\n\n    Args:\n        vectors_with_angle (dataframe): outputs from calc_angles function\n        alpha (degree): fire spread sector angle (alpha angle), value from 0 to 360\n\n    Returns:\n        dataframe: a dataframe containing geometry of i, j, ignition point and beta angle value of each vector\n    \"\"\"    \n    maxAngle = alpha/2+180\n    minAngle = 180-alpha/2\n    vectorsV = vectors_with_angle.copy()\n    vectorsV.drop(vectorsV.loc[vectorsV['angle'] &gt; maxAngle].index, inplace = True)\n    vectorsV.drop(vectorsV.loc[vectorsV['angle'] &lt; minAngle].index, inplace = True)\n    vectorsV.sort_values(by = ['fire','day'], inplace = True)\n    vectorsV.reset_index(drop = True, inplace = True)\n    return vectorsV\n</code></pre>"},{"location":"dataloader/","title":"dataloader module","text":"<p>Module handling input files. 1. read in input fire shapefile. 2. read in input csv file of ignition points, and convert it to shapefile of the same projection as fire shp. 3. optionally parsing the big input files into chunks for parallel processing and saving time.</p>"},{"location":"dataloader/#postbp.dataloader.read_fireshp","title":"<code>read_fireshp(path_n_file_name, daily=False)</code>","text":"<p>Load the files with the final and daily fire perimeters and prepares the data</p> <p>Parameters:</p> Name Type Description Default <code>path_n_file_name</code> <code>string</code> <p>path and file name of fire perimeter shapefile</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>ignition point fire ID and geometry</p> Source code in <code>postbp/dataloader.py</code> <pre><code>def read_fireshp(path_n_file_name, daily=False):\n    \"\"\"Load the files with the final and daily fire perimeters and prepares the data\n\n    Args:\n        path_n_file_name (string): path and file name of fire perimeter shapefile\n\n    Returns:\n        GeoDataFrame: ignition point fire ID and geometry\n    \"\"\"    \n     # check whether it is a daily progression shapefile\n\n    fire = gpd.read_file(path_n_file_name,  driver = 'ESRI Shapefile') #columns=columns,\n\n    # as geopands has malfunction in reading only the columns being specified, we manually redundantly do it again here\n    if daily:\n        fire = fire[['fire', 'iteration', 'day', 'geometry']]\n    else:\n        fire = fire[['fire', 'iteration', 'geometry']]\n\n    # some BP3 fireshp data does not have valid prj, it needs to have a warning to the users\n    if not fire.crs:\n        print('The fire perimeter shapefile does not have a valid projection, please set a valid SRID.')\n\n    return fire\n</code></pre>"},{"location":"dataloader/#postbp.dataloader.read_pointcsv","title":"<code>read_pointcsv(path_n_file_name, SRID, **kwargs)</code>","text":"<p>Load the fire ignition points if this information is provided as a comma-delimited .csv file</p> <p>Parameters:</p> Name Type Description Default <code>path_n_file_name</code> <code>string</code> <p>path and file name of fire ignition points shapefile</p> required <code>SRID</code> <code>CRS</code> <p>spatial reference identifiers (SRID) </p> required <code>x_col</code> <code>str</code> <p>column name of x coordinates, default to be 'x_coord'</p> required <code>y_col</code> <code>str</code> <p>column name of x coordinates, default to be 'y_coord'</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>ignition point fire ID and geometry</p> Source code in <code>postbp/dataloader.py</code> <pre><code>def read_pointcsv(path_n_file_name, SRID, **kwargs):\n    \"\"\"Load the fire ignition points if this information is provided as a comma-delimited .csv file\n\n    Args:\n        path_n_file_name (string): path and file name of fire ignition points shapefile\n        SRID (CRS): spatial reference identifiers (SRID) \n        x_col (str): column name of x coordinates, default to be 'x_coord'\n        y_col (str): column name of x coordinates, default to be 'y_coord'\n    Returns:\n        GeoDataFrame: ignition point fire ID and geometry\n    \"\"\"    \n\n    if \"x_col\" in kwargs:\n        x_col = kwargs['x_col']\n    else:\n        x_col = 'x_coord'\n\n    if \"y_col\" in kwargs:\n        y_col = kwargs['y_col']\n    else:\n        y_col = 'y_coord'\n\n    #### read in BurnP-3 output ignition point csv file\n    points = pd.read_csv(path_n_file_name)\n    # points.columns=points.columns.str.strip()\n    points['geometry'] = [Point(xy) for xy in zip(points[x_col], points[y_col])]\n    # note: make sure ignition points and fire shape are of the same projection, below it directly set by prj\n    points = gpd.GeoDataFrame(points, crs = SRID, geometry = points['geometry'] )\n    points = points[['fire', 'iteration', 'geometry']]\n    return points\n</code></pre>"},{"location":"dataloader/#postbp.dataloader.read_pointshp","title":"<code>read_pointshp(path_n_file_name, **kwargs)</code>","text":"<p>Load the ignition points if the data is provided as X-Y coordinates in separate columns in the attribute table of the ESRI shapefile with fire perimeters (or in a separate ESRI point shapefile)</p> <p>Parameters:</p> Name Type Description Default <code>path_n_file_name</code> <code>str</code> <p>path and file name of fire ignition points shapefile</p> required <code>x_col</code> <code>str</code> <p>column name of x coordinates, default to be 'x_coord'</p> required <code>y_col</code> <code>str</code> <p>column name of x coordinates, default to be 'y_coord'</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>ignition point fire ID and geometry</p> Source code in <code>postbp/dataloader.py</code> <pre><code>def read_pointshp(path_n_file_name, **kwargs):\n    \"\"\"Load the ignition points if the data is provided as X-Y coordinates in separate columns in the attribute table of the ESRI shapefile with fire perimeters (or in a separate ESRI point shapefile)\n\n    Args:\n        path_n_file_name (str): path and file name of fire ignition points shapefile\n        x_col (str): column name of x coordinates, default to be 'x_coord'\n        y_col (str): column name of x coordinates, default to be 'y_coord'\n    Returns:\n        GeoDataFrame: ignition point fire ID and geometry\n    \"\"\" \n\n    if \"x_col\" in kwargs:\n        x_col = kwargs['x_col']\n\n    else:\n        x_col = 'x_coord'\n\n    if \"y_col\" in kwargs:\n        y_col = kwargs['y_col']\n    else:\n        y_col = 'y_coord'\n\n    #### read in BurnP-3 output ignition point csv file\n    points = gpd.read_file(path_n_file_name, driver='ESRI Shapefile')\n    ## check geometry to be point or polygon\n\n    if points.geom_type.str.contains(\"Point\").all():\n        points = points[['fire', 'iteration', 'geometry']]\n\n    else:\n        SRID = points.crs\n        points.drop(labels='geometry',axis=1,inplace=True)\n        points = points[['fire', 'iteration']]\n        points['geometry'] = [Point(xy) for xy in zip(points[x_col], points[y_col])]\n        # note: make sure ignition points and fire shape are of the same projection, below it directly set by prj\n        points = gpd.GeoDataFrame(points, crs = SRID, geometry = points['geometry'] )\n        points = points[['fire', 'iteration', 'geometry']]\n\n    return points\n</code></pre>"},{"location":"dataloader/#postbp.dataloader.validify_fireshp","title":"<code>validify_fireshp(fireshp)</code>","text":"<p>if encounter error message of invalid geometry, use this function to convert invalid geometry to valid ones</p> <p>Parameters:</p> Name Type Description Default <code>fireshp</code> <code>GeoDataFrame</code> <p>fire perimeter dataset with fire ID (and iteration ID) and geometry</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return validified geodataframe</p> Source code in <code>postbp/dataloader.py</code> <pre><code>def validify_fireshp(fireshp):\n    \"\"\"if encounter error message of invalid geometry, use this function to convert invalid geometry to valid ones\n\n    Args:\n        fireshp (GeoDataFrame): fire perimeter dataset with fire ID (and iteration ID) and geometry\n\n    Returns:\n        GeoDataFrame: return validified geodataframe\n    \"\"\"    \n    from shapely.validation import make_valid\n    fireshp.geometry = fireshp.apply(lambda row: make_valid(row.geometry) if not row.geometry.is_valid else row.geometry, axis=1)\n    return fireshp\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"finalfirevectors/","title":"finalfirevectors module","text":"<p>Module to project fire and ignition points to hexagon network. 1. user confirm whether there are multiple fires in each iteration:     if yes, using spatialjoin_fire_iteration     else, using spatialjoin_fire</p> <ol> <li>user confirm whether is processing spreading by day data:     if yes, using module dailyfirevectors     else, current module suffices</li> </ol>"},{"location":"finalfirevectors/#postbp.finalfirevectors.generate_fire_vectors","title":"<code>generate_fire_vectors(fireshp, ignition, hexagons, threshold=0, loopBy='fire', **kwargs)</code>","text":"<p>Generate fire spreading vectors from final fire spread perimeters</p> <p>Parameters:</p> Name Type Description Default <code>fireshp</code> <code>GeoDataFrame</code> <p>fire perimeter dataset with fire ID (and iteration ID) and geometry</p> required <code>ignition</code> <code>GeoDataFrame</code> <p>ignition point shapes with fire ID field in attributes</p> required <code>hexagons</code> <code>GeoDataFrame</code> <p>geometry of hexagonal patches with ID field</p> required <code>threshold</code> <code>float</code> <p>Value between 0 and 1. The proportion for classifying hexagon as intersecting with shp0. Defaults to 0.</p> <code>0</code> <code>loopBy</code> <code>str</code> <p>loop by 'fire' of 'iteration'. Defaults to \"fire\".</p> <code>'fire'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>a dataframe table containing fire starting hexagon ID (i), destination hexagon ID (j), fire ID, and ignition hexagon ID </p> Source code in <code>postbp/finalfirevectors.py</code> <pre><code>def generate_fire_vectors(fireshp, ignition, hexagons, threshold = 0, loopBy = \"fire\", **kwargs):\n    \"\"\"Generate fire spreading vectors from final fire spread perimeters\n\n    Args:\n        fireshp (GeoDataFrame): fire perimeter dataset with fire ID (and iteration ID) and geometry\n        ignition (GeoDataFrame): ignition point shapes with fire ID field in attributes\n        hexagons (GeoDataFrame): geometry of hexagonal patches with ID field\n        threshold (float, optional): Value between 0 and 1. The proportion for classifying hexagon as intersecting with shp0. Defaults to 0.\n        loopBy (str, optional): loop by 'fire' of 'iteration'. Defaults to \"fire\".\n\n    Returns:\n        DataFrame: a dataframe table containing fire starting hexagon ID (i), destination hexagon ID (j), fire ID, and ignition hexagon ID \n    \"\"\"    \n    hexagon = hexagons.copy()\n    if 'Node_ID' in kwargs:\n        hexagon = hexagon.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n\n    if loopBy == \"iteration\":\n        fire_vectors = _spatial_join(fireshp, ignition, hexagon, threshold, iteration=True)\n\n    if loopBy == \"fire\":\n        fire_vectors = _spatial_join(fireshp, ignition, hexagon, threshold, iteration=False)\n\n    fire_vectors = fire_vectors.reset_index(drop = True)\n    fire_vectors.drop(fire_vectors[fire_vectors['Node_ID_y'].isna()].index, inplace = True)                    \n\n    fire_vectors['Node_ID_x'] = fire_vectors['Node_ID_x'].astype(int)\n    fire_vectors['Node_ID_y'] = fire_vectors['Node_ID_y'].astype(int)\n\n    fire_vectors.columns = ['Node_ID_x', 'Node_ID_y', 'fire', 'iteration']\n    fire_vectors.rename(columns={'Node_ID_x':'column_j', 'Node_ID_y':'column_i'}, inplace=True)\n    return fire_vectors\n</code></pre>"},{"location":"finalfirevectors/#postbp.finalfirevectors.pij_from_vectors","title":"<code>pij_from_vectors(vectors, iterations)</code>","text":"<p>Group vector pair by i, j and calculate probability by dividing number of occurrence by number of iterations</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>dataframe</code> <p>outputs from generate_fire_vectors function</p> required <code>iterations</code> <code>int</code> <p>number of iterations</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return a geodataframe with probability values for pairs of i, j on the landscape</p> Source code in <code>postbp/finalfirevectors.py</code> <pre><code>def pij_from_vectors(vectors, iterations):\n    \"\"\"Group vector pair by i, j and calculate probability by dividing number of occurrence by number of iterations\n\n    Args:\n        vectors (dataframe): outputs from generate_fire_vectors function\n        iterations (int): number of iterations\n\n    Returns:\n        GeoDataFrame: return a geodataframe with probability values for pairs of i, j on the landscape\n    \"\"\"    \n\n    fire_pij = vectors.groupby(['column_j', 'column_i'])[['fire']].count()\n    fire_pij.reset_index(inplace = True)\n    fire_pij = fire_pij.drop(fire_pij[fire_pij['column_j'] == fire_pij['column_i']].index)\n    fire_pij['pij'] = fire_pij['fire'] / iterations\n    fire_pij['pij'] = fire_pij['pij'].round(7)\n    fire_pij['pij'] = fire_pij['pij'].apply(lambda x: '%.7f' % x)\n    fire_pij.rename(columns={'fire':'firecounts'},inplace=True)\n    fire_pij.sort_values(by = ['column_i', 'column_j'], inplace = True)\n    fire_pij.reset_index(drop=True, inplace=True)\n    return fire_pij\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install postbp, run this command in your terminal:</p> <pre><code>pip install postbp\n</code></pre> <p>This is the preferred method to install postbp.</p> <p>To upgrade postbp to a newer release, run this command in your terminal:</p> <pre><code>pip install postbp --upgrade\n</code></pre> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install postbp from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/nliu-cfs/postbp\n</code></pre>"},{"location":"postbp/","title":"postbp module","text":"<p># postbp module</p> <p>Main module.</p>"},{"location":"postbp/#postbp.postbp.generate_burn_prob","title":"<code>generate_burn_prob(fireshp, hexagons, iterations, **kwargs)</code>","text":"<p>Generate shapefile of hexagonal network with values of burn likelihood for each hexagon on the landscape</p> <p>Parameters:</p> Name Type Description Default <code>fireshp</code> <code>GeoDataFrame</code> <p>fire perimeter dataset with fire ID (and iteration ID) and geometry</p> required <code>hexagons</code> <code>GeoDataFrame</code> <p>geometry of hexagonal patches with ID field</p> required <code>iterations</code> <code>int</code> <p>number of iterations</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return a GeoDataFrame containing burn probability value at each hexagonal patches</p> Source code in <code>postbp/postbp.py</code> <pre><code>def generate_burn_prob(fireshp, hexagons, iterations, **kwargs):\n    \"\"\"Generate shapefile of hexagonal network with values of burn likelihood\n    for each hexagon on the landscape\n\n    Args:\n        fireshp (GeoDataFrame): fire perimeter dataset with fire ID (and iteration ID) and geometry\n        hexagons (GeoDataFrame): geometry of hexagonal patches with ID field\n        iterations (int): number of iterations\n\n    Returns:\n        GeoDataFrame: return a GeoDataFrame containing burn probability value at each hexagonal patches\n    \"\"\"    \n    if 'threshold' in kwargs:\n        threshold = kwargs['threshold']\n    else:\n        threshold = 0\n    hexagon = hexagons.copy()\n    if 'Node_ID' in kwargs:\n        hexagon = hexagon.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n\n    fireOL = prj2hex(fireshp, hexagon, threshold=threshold)\n    if 'fire_column' in kwargs:\n        fireOL.rename(columns={kwargs[\"fire_column\"]: 'fire'}, inplace=True) \n\n    burned = fireOL.groupby('Node_ID')[['fire']].count()\n    burned.reset_index(inplace=True)\n    burnP = hexagon.merge(burned, on='Node_ID', how='left')\n    burnP.fillna(0, inplace=True)\n    burnP['burnProb'] = burnP['fire']/iterations*100\n    burnP = burnP[['Node_ID', 'burnProb', 'geometry']]\n    return burnP\n</code></pre>"},{"location":"postbp/#postbp.postbp.generate_fireplain","title":"<code>generate_fireplain(fire_vectors, AOCshp, fireshp, hexagons, **kwargs)</code>","text":"<p>Generate the fireplain in regard to an area of concern (AOC) based on the fire vectors</p> <p>Parameters:</p> Name Type Description Default <code>fire_vectors</code> <code>DataFrame</code> <p>outputs from generate_fire_vectors function</p> required <code>AOCshp</code> <code>GeoDataFrame</code> <p>geometry of the area of concern</p> required <code>fireshp</code> <code>GeoDataFrame</code> <p>fire perimeter dataset with fire ID (and iteration ID) and geometry</p> required <code>hexagons</code> <code>GeoDataFrame</code> <p>geometry of hexagonal patches with ID field</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return a geodataframe of dissolved geometry of the fireplain for fires ignited in the area of concern.</p> Source code in <code>postbp/postbp.py</code> <pre><code>def generate_fireplain(fire_vectors, AOCshp, fireshp, hexagons, **kwargs):\n    \"\"\"Generate the fireplain in regard to an area of concern (AOC) based on the fire vectors\n\n    Args:\n        fire_vectors (DataFrame): outputs from generate_fire_vectors function\n        AOCshp (GeoDataFrame): geometry of the area of concern\n        fireshp (GeoDataFrame): fire perimeter dataset with fire ID (and iteration ID) and geometry\n        hexagons (GeoDataFrame): geometry of hexagonal patches with ID field\n\n    Returns:\n        GeoDataFrame: return a geodataframe of dissolved geometry of the fireplain for fires ignited in the area of concern.\n    \"\"\"\n    hexagon = hexagons.copy()\n    if 'Node_ID' in kwargs:\n        hexagon = hexagon.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n    fv = fire_vectors.copy()\n    if 'column_i' in kwargs:\n        fv.rename(columns={kwargs[\"column_i\"]: 'column_i'}, inplace=True)    \n    if 'column_j' in kwargs:\n        fv.rename(columns={kwargs[\"column_j\"]: 'column_j'}, inplace=True)\n    if 'fire_column' in kwargs:\n        fv.renmae(columns={kwargs['fire_column']: 'fire'}, inplace=True) \n\n    aoc = prj2hex(AOCshp, hexagon, threshold=0)\n    fireAOC = fire_vectors.loc[fire_vectors['i'].isin(aoc['Node_ID'])]\n    fireAOCshp = fireshp.merge(fireAOC, on='fire', how='right')\n    fireAOCshp['V'] = 1\n    fireAOCshp = fireAOCshp.dissolve(by='V')\n    fireAOCshp['area_ha'] = fireAOCshp.area/10000\n    return fireAOCshp\n</code></pre>"},{"location":"postbp/#postbp.postbp.generate_fireshed","title":"<code>generate_fireshed(fire_vectors, AOCshp, fireshp, hexagons, **kwargs)</code>","text":"<p>Generate the fireshed in regard to an area of concern (AOC) based on the fire vectors </p> <p>Parameters:</p> Name Type Description Default <code>fire_vectors</code> <code>DataFrame</code> <p>outputs from generate_fire_vectors function</p> required <code>AOCshp</code> <code>GeoDataFrame</code> <p>geometry of the area of concern</p> required <code>fireshp</code> <code>GeoDataFrame</code> <p>fire perimeter dataset with fire ID (and iteration ID) and geometry</p> required <code>hexagons</code> <code>GeoDataFrame</code> <p>geometry of hexagonal patches with ID field</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return a geodataframe of dissolved geometry of the fireshed of fires that can burn into the area of concern.</p> Source code in <code>postbp/postbp.py</code> <pre><code>def generate_fireshed(fire_vectors, AOCshp, fireshp, hexagons, **kwargs):\n    \"\"\"Generate the fireshed in regard to an area of concern (AOC) based on the fire vectors \n\n    Args:\n        fire_vectors (DataFrame): outputs from generate_fire_vectors function\n        AOCshp (GeoDataFrame): geometry of the area of concern\n        fireshp (GeoDataFrame): fire perimeter dataset with fire ID (and iteration ID) and geometry\n        hexagons (GeoDataFrame): geometry of hexagonal patches with ID field\n\n    Returns:\n        GeoDataFrame: return a geodataframe of dissolved geometry of the fireshed of fires that can burn into the area of concern.\n    \"\"\"    \n    hexagon = hexagons.copy()\n    if 'Node_ID' in kwargs:\n        hexagon = hexagon.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n    fv = fire_vectors.copy()\n    if 'column_i' in kwargs:\n        fv.rename(columns={kwargs[\"column_i\"]: 'column_i'}, inplace=True)    \n    if 'column_j' in kwargs:\n        fv.rename(columns={kwargs[\"column_j\"]: 'column_j'}, inplace=True)\n    if 'fire_column' in kwargs:\n        fv.renmae(columns={kwargs['fire_column']: 'fire'}, inplace=True)     \n\n    aoc = prj2hex(AOCshp, hexagon, threshold=0)\n    fireAOC = fv.loc[fv['column_j'].isin(aoc['Node_ID'])]\n    fireAOCshp = fireshp.merge(fireAOC, on='fire', how='right')\n    fireAOCshp['V'] = 1\n    fireAOCshp = fireAOCshp.dissolve(by='V')\n    fireAOCshp['area_ha'] = fireAOCshp.area/10000\n    return fireAOCshp\n</code></pre>"},{"location":"postbp/#postbp.postbp.generate_ign_prob","title":"<code>generate_ign_prob(ignition, hexagons, iterations, **kwargs)</code>","text":"<p>Generate shapefile of hexagonal network with values of ignition likelihood for each hexagon on the landscape</p> <p>Parameters:</p> Name Type Description Default <code>ignition</code> <code>_type_</code> <p>description</p> required <code>hexagons</code> <code>GeoDataFrame</code> <p>geometry of hexagonal patches with ID field</p> required <code>iterations</code> <code>int</code> <p>number of iterations</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return a GeoDataFrame containing ignition probability value at each hexagonal patches</p> Source code in <code>postbp/postbp.py</code> <pre><code>def generate_ign_prob(ignition, hexagons, iterations, **kwargs):\n    \"\"\"Generate shapefile of hexagonal network with values of ignition likelihood\n    for each hexagon on the landscape\n\n    Args:\n        ignition (_type_): _description_\n        hexagons (GeoDataFrame): geometry of hexagonal patches with ID field\n        iterations (int): number of iterations\n    Returns:\n        GeoDataFrame: return a GeoDataFrame containing ignition probability value at each hexagonal patches\n\n    \"\"\"    \n\n    ign = ignition.copy()\n    hexagon = hexagons.copy()\n    if 'Node_ID' in kwargs:\n        hexagon = hexagon.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n    if 'fire_column' in kwargs:\n        ign.rename(columns={kwargs[\"fire_column\"]: 'fire'}, inplace=True)    \n\n    ignSJ = gpd.sjoin(ign, hexagon, how = 'inner', op = 'within')\n    ignGr = ignSJ.groupby(['Node_ID'])[['fire']].count()\n    ignGr = hexagon.merge(ignGr, on='Node_ID', how='right')\n    ignGr.fillna(0, inplace=True)\n    ignGr['ignProb'] = ignGr['fire']/iterations*100\n    ignGr = ignGr[['Node_ID', 'ignProb', 'geometry']]\n    return ignGr\n</code></pre>"},{"location":"postbp/#postbp.postbp.generate_ssr","title":"<code>generate_ssr(fire_vectors, hexagons, **kwargs)</code>","text":"<p>Generate a shapefile with values of Source-Sink-Ratio based on the fire vectors </p> <p>Parameters:</p> Name Type Description Default <code>fire_vectors</code> <code>DataFrame</code> <p>outputs from generate_fire_vectors function</p> required <code>hexagons</code> <code>GeoDataFrame</code> <p>geometry of hexagonal patches with ID field</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return a GeoDataFrame containing the Source-Sink Ratio value at each hexagonal patches</p> Source code in <code>postbp/postbp.py</code> <pre><code>def generate_ssr(fire_vectors, hexagons, **kwargs):\n    \"\"\"Generate a shapefile with values of Source-Sink-Ratio based on the fire vectors \n\n    Args:\n        fire_vectors (DataFrame): outputs from generate_fire_vectors function\n        hexagons (GeoDataFrame): geometry of hexagonal patches with ID field\n\n    Returns:\n        GeoDataFrame: return a GeoDataFrame containing the Source-Sink Ratio value at each hexagonal patches\n    \"\"\"    \n    hexagon = hexagons.copy()\n    if 'Node_ID' in kwargs:\n        hexagon = hexagon.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n    fv = fire_vectors.copy()\n    if 'column_i' in kwargs:\n        fv.rename(columns={kwargs[\"column_i\"]: 'column_i'}, inplace=True)    \n    if 'column_j' in kwargs:\n        fv.rename(columns={kwargs[\"column_j\"]: 'column_j'}, inplace=True)\n    if 'fire_column' in kwargs:\n        fv.renmae(columns={kwargs['fire_column']: 'fire'}, inplace=True) \n\n    fire_orig = fv.groupby('column_i')[['fire']].count()\n    fire_orig.reset_index(inplace=True)\n    fire_orig.rename(columns={'fire':'asSource'}, inplace=True)\n    fire_dest = fire_vectors.groupby('column_j')[['fire']].count()\n    fire_dest.reset_index(inplace=True)\n    fire_dest.rename(columns={'fire':'asSink'}, inplace=True)\n    fireSSR = hexagon.merge(fire_orig, left_on='Node_ID', right_on='column_i', how='left')\n    fireSSR = fireSSR.merge(fire_dest, left_on='Node_ID', right_on='column_j', how='left')\n    fireSSR['SSR'] = np.log10(fireSSR['asSource'] / fireSSR['asSink'])\n    fireSSR.dropna(inplace=True)\n    return fireSSR\n</code></pre>"},{"location":"spreadrose/","title":"spreadrose module","text":""},{"location":"spreadrose/#postbp.spreadrose.angle_from_2pts","title":"<code>angle_from_2pts(p1, p2)</code>","text":"<p>Calculate the clockwise angles between the fire vector and the North from start and end points of a vector.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>GeoDataFrame</code> <p>starting point of a vector with geometry.</p> required <code>p2</code> <code>GeoDataFrame</code> <p>end point of a vector with geometry.</p> required <p>Returns:</p> Type Description <code>degree</code> <p>return angle value</p> Source code in <code>postbp/spreadrose.py</code> <pre><code>def angle_from_2pts(p1, p2):\n    \"\"\"Calculate the clockwise angles between the fire vector and the North from start and end points of a vector.\n\n    Args:\n        p1 (GeoDataFrame): starting point of a vector with geometry.\n        p2 (GeoDataFrame): end point of a vector with geometry.\n\n    Returns:\n        degree: return angle value\n    \"\"\"    \n    x0, y0 = p1['geometry'].x,p1['geometry'].y\n    x1, y1 = p2['geometry'].x, p2['geometry'].y\n    dy = y0 - y1\n    dx = x0 - x1\n    theta = atan2(dx, dy)\n    angle = degrees(theta)\n    if angle &lt; 0:\n        angle = 360 + angle\n    return angle\n</code></pre>"},{"location":"spreadrose/#postbp.spreadrose.angle_from_pij","title":"<code>angle_from_pij(record)</code>","text":"<p>Calculate the clockwise angles between the fire vector and the North from postbp function generate_daily_vectors.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>DataFrame</code> <p>a row of outputs from pij_from_vectors function</p> required <p>Returns:</p> Type Description <code>degree</code> <p>return angle value</p> Source code in <code>postbp/spreadrose.py</code> <pre><code>def angle_from_pij(record):\n    \"\"\"Calculate the clockwise angles between the fire vector and the North from postbp function generate_daily_vectors.\n\n    Args:\n        record (DataFrame): a row of outputs from pij_from_vectors function\n\n    Returns:\n        degree: return angle value\n    \"\"\"    \n    x0, y0 = record['geometry_x'].x, record['geometry_x'].y\n    x1, y1 = record['geometry_y'].x, record['geometry_y'].y\n    dy = y0 - y1\n    dx = x0 - x1\n    theta = atan2(dx, dy)\n    angle = degrees(theta)\n    if angle &lt; 0:\n        angle = 360 + angle\n    return angle\n</code></pre>"},{"location":"spreadrose/#postbp.spreadrose.generate_fire_rose","title":"<code>generate_fire_rose(pijVectors, nodes, **kwargs)</code>","text":"<p>Prepare data for plotting fire rose.</p> <p>Parameters:</p> Name Type Description Default <code>pijVectors</code> <code>DataFrame</code> <p>outputs from pij_from_vectors function</p> required <code>nodes</code> <code>GeoDataFrame</code> <p>centroid points of the hexagonal patch network</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>return a dataframe containing angles, pij, and distance of spread. </p> Source code in <code>postbp/spreadrose.py</code> <pre><code>def generate_fire_rose(pijVectors, nodes, **kwargs):\n    \"\"\"Prepare data for plotting fire rose.\n\n    Args:\n        pijVectors (DataFrame): outputs from pij_from_vectors function\n        nodes (GeoDataFrame): centroid points of the hexagonal patch network\n\n    Returns:\n        DataFrame: return a dataframe containing angles, pij, and distance of spread. \n    \"\"\"    \n    node = nodes.copy()\n    pij = pijVectors.copy() \n    if 'Node_ID' in kwargs:\n        node = node.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n    if 'column_i' in kwargs:\n        pij.rename(columns={kwargs[\"column_i\"]: 'column_i'}, inplace=True)    \n    if 'column_j' in kwargs:\n        pij.rename(columns={kwargs[\"column_j\"]: 'column_j'}, inplace=True)     \n\n    pij = node.merge(pij, left_on = 'Node_ID', right_on = 'column_i', how = 'right')\n    pij = pij.merge(node, left_on = 'column_j', right_on = 'Node_ID', how = 'left')    \n    pij.drop(labels = ['Node_ID_x', 'Node_ID_y'], axis = 1, inplace = True)\n    for index, row in tqdm(pij.iterrows()):\n        pij.at[index, 'angle'] = angle_from_pij(row)\n    dffLine = [LineString(xy) for xy in zip(pij['geometry_x'], pij['geometry_y'])]\n    pij = gpd.GeoDataFrame(pij, crs = node.crs, geometry = dffLine )\n    pij.drop(labels = ['geometry_x', 'geometry_y'], axis = 1, inplace = True)\n    pij['len'] = pij.geometry.length\n    pij['pij'] = pij['pij'].astype(float)\n    return pij\n</code></pre>"},{"location":"spreadrose/#postbp.spreadrose.plot_rose","title":"<code>plot_rose(pijRose, column='pij', save=False)</code>","text":"<p>Plot fire rose.</p> <p>Parameters:</p> Name Type Description Default <code>pijRose</code> <code>DataFrame</code> <p>a dataframe containing angles, pij, and distance of spread. </p> required <code>column</code> <code>str</code> <p>value can be 'pij' or 'len'. Defaults to 'pij'.</p> <code>'pij'</code> <code>save</code> <code>bool</code> <p>whether save the plot to current repository or plot on screen. Defaults to False.</p> <code>False</code> Source code in <code>postbp/spreadrose.py</code> <pre><code>def plot_rose(pijRose, column='pij', save = False):\n    \"\"\"Plot fire rose.\n\n    Args:\n        pijRose (DataFrame): a dataframe containing angles, pij, and distance of spread. \n        column (str, optional): value can be 'pij' or 'len'. Defaults to 'pij'.\n        save (bool, optional): whether save the plot to current repository or plot on screen. Defaults to False.\n    \"\"\"    \n\n    plt.rcParams.update({'font.size': 20,\"legend.frameon\":False})\n    ax = WindroseAxes.from_ax()\n    ax.bar(pijRose['angle'], pijRose[column], normed=True, blowto=False, cmap=cm.Set2, opening=0.8, edgecolor='white')\n    ax.set_legend(fontsize=\"20\",loc=(1.1, 0.01))\n    if save:\n        plt.savefig(column + 'Rose.png', bbox_inches='tight', pad_inches=.1, transparent=False)\n        plt.close()\n    else:\n        plt.show()\n\n    plt.rcParams.update(plt.rcParamsDefault)\n</code></pre>"},{"location":"tessellation/","title":"tessellation module","text":"<p>Module for setting up hexagon network.</p> <ol> <li>grabs the spatial bounds of fire shapefile.</li> <li>using user-defined area value to build hexagon network on the bounded area. </li> <li>projection of the hexagon network to be the same as that of the fire shapefile.</li> <li>generate the centroid of the hexes as nodes shapefile</li> <li>generate arcs connecting neighbouring nodes</li> </ol>"},{"location":"tessellation/#postbp.tessellation.create_arcs","title":"<code>create_arcs(hexagons, **kwargs)</code>","text":"<p>Create geometry of arcs connecting each neighbouring hexagons.</p> <p>Parameters:</p> Name Type Description Default <code>hexagons</code> <code>GeoDataFrame</code> <p>geometry and ID of hexagonal patches</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return arcs geometry with attributes indicating IDs of the two hexagons it connects.</p> Source code in <code>postbp/tessellation.py</code> <pre><code>def create_arcs(hexagons, **kwargs):\n    \"\"\"Create geometry of arcs connecting each neighbouring hexagons.\n\n    Args:\n        hexagons (GeoDataFrame): geometry and ID of hexagonal patches\n\n    Returns:\n        GeoDataFrame: return arcs geometry with attributes indicating IDs of the two hexagons it connects.\n    \"\"\"    \n    hexagon = hexagons.copy()\n    if 'Node_ID' in kwargs:\n        hexagon = hexagon.rename(columns={kwargs[\"Node_ID\"]: 'Node_ID'})\n\n    nodes = nodes_from_hexagons(hexagon)\n    nodes = nodes.set_index('Node_ID')\n    SRID = hexagon.crs\n    hexagon = hexagon.set_index('Node_ID')\n\n    arcs = gpd.GeoDataFrame()\n    df=gpd.GeoDataFrame()\n    for index, _ in tqdm(hexagon.iterrows()):\n        nnnn = hexagon[~hexagon.geometry.disjoint(hexagon.at[index,'geometry'])].index.tolist()\n        nnnn = [i for i in nnnn if index != i]\n        mmmm = [index] * len(nnnn)\n        mmnn = [LineString(xy) for xy in zip(nodes.loc[mmmm].geometry, nodes.loc[nnnn].geometry)]\n        mmnn = gpd.GeoDataFrame(df, crs = SRID, geometry = mmnn )\n        mmnn['Node_1'] = mmmm\n        mmnn['Node_2'] = nnnn\n        arcs = pd.concat([arcs,mmnn])\n\n    arcs['Node_1'] = arcs['Node_1'].astype(int)\n    arcs['Node_2'] = arcs['Node_2'].astype(int)\n    arcs.reset_index(drop=True, inplace=True)\n\n    return arcs\n</code></pre>"},{"location":"tessellation/#postbp.tessellation.create_hexagons","title":"<code>create_hexagons(boundaryShp, offset_x=0, offset_y=0, **kwargs)</code>","text":"<p>Creat geodataframe of hexagonal patches of defined size and range.    Hexagon size can be defined in area, side length, or long diameter. Must input one parameter out of the three options.</p> <p>Parameters:</p> Name Type Description Default <code>boundaryShp</code> <code>GeoDataFrame</code> <p>the geodataframe defines the range covered by the hexagonal patches</p> required <code>area</code> <code>float, OPTIONAL</code> <p>define the size of each hexagon by area in square meters</p> required <code>side</code> <code>float, OPTIONAL</code> <p>define the size of each hexagon by side length in meter</p> required <code>diameter</code> <code>float, OPTIONAL</code> <p>define the size of each hexagon by long diameter in meter</p> required <code>offset_x</code> <code>fraction, OPTIONAL</code> <p>defines the horizontal offset for hexagons as a fraction of the length of the hexagon's long diagonal. Can be positive or negative.</p> <code>0</code> <code>offset_y</code> <code>fraction, OPTIONAL</code> <p>defines the vertical offset for hexagons as a fraction of the length of the hexagon's long diagonal. Can be positive or negative.</p> <code>0</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return a geodataframe of hexagonal network of the defined size and covering the defined range.</p> Source code in <code>postbp/tessellation.py</code> <pre><code>def create_hexagons(boundaryShp, offset_x=0, offset_y=0, **kwargs):\n    \"\"\"Creat geodataframe of hexagonal patches of defined size and range.\n       Hexagon size can be defined in area, side length, or long diameter. Must input one parameter out of the three options.\n    Args:\n        boundaryShp (GeoDataFrame): the geodataframe defines the range covered by the hexagonal patches\n        area (float, OPTIONAL): define the size of each hexagon by area in square meters\n        side (float, OPTIONAL): define the size of each hexagon by side length in meter\n        diameter (float, OPTIONAL): define the size of each hexagon by long diameter in meter\n        offset_x (fraction, OPTIONAL): defines the horizontal offset for hexagons as a fraction of the length of the hexagon's long diagonal. Can be positive or negative.\n        offset_y (fraction, OPTIONAL): defines the vertical offset for hexagons as a fraction of the length of the hexagon's long diagonal. Can be positive or negative.\n\n    Returns:\n        GeoDataFrame: return a geodataframe of hexagonal network of the defined size and covering the defined range.\n    \"\"\"   \n    if 'area' in kwargs:\n        area = kwargs['area']\n\n    elif \"side\" in kwargs:\n        area = kwargs[\"side\"]**2*3/2*math.sqrt(3)\n\n    elif \"diameter\" in kwargs:\n        area = kwargs[\"diameter\"]**2*3/8*math.sqrt(3)\n\n    else:\n        print('Please define a value using one of the following parameters: area, side, or diameter of the intended hexagonal patches.')\n\n    myCRS = boundaryShp.crs\n    xmin,ymin,xmax,ymax =  boundaryShp.total_bounds\n    nodes = _create_hexnodes(area, xmin, ymin, xmax, ymax, offset_x, offset_y)\n    hexagons = [_create_hexgrids(area, node[0], node[1]) for node in nodes]\n\n    nodes = [Point(node) for node in nodes]\n    nodes = gpd.GeoDataFrame({'geometry': nodes})\n    nodes['Node_ID'] = nodes.index + 1\n    nodes.crs = myCRS\n    hexagons = gpd.GeoDataFrame({'geometry':hexagons})\n    hexagons['Node_ID'] = hexagons.index + 1\n    hexagons.crs = myCRS\n\n    return hexagons\n</code></pre>"},{"location":"tessellation/#postbp.tessellation.create_hexagons_nodes","title":"<code>create_hexagons_nodes(boundaryShp, offset_x=0, offset_y=0, **kwargs)</code>","text":"<p>Creat geodataframe of hexagonal patches and the nodes (centroids) of the hexagons of defined size and range.    Hexagon size can be defined in area, side length, or long diameter. Must input one parameter out of the three options.</p> <p>Parameters:</p> Name Type Description Default <code>boundaryShp</code> <code>GeoDataFrame</code> <p>the geodataframe defines the range covered by the hexagonal patches</p> required <code>area</code> <code>float, OPTIONAL</code> <p>define the size of each hexagon by area in square meters</p> required <code>side</code> <code>float, OPTIONAL</code> <p>define the size of each hexagon by side length in meter</p> required <code>diameter</code> <code>float, OPTIONAL</code> <p>define the size of each hexagon by long diameter in meter</p> required <code>offset_x</code> <code>fraction, OPTIONAL</code> <p>defines the horizontal offset for hexagons as a fraction of the length of the hexagon's long diagonal. Can be positive or negative.</p> <code>0</code> <code>offset_y</code> <code>fraction, OPTIONAL</code> <p>defines the vertical offset for hexagons as a fraction of the length of the hexagon's long diagonal. Can be positive or negative.</p> <code>0</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return geodataframes of hexagons and nodes of the defined size and covering the defined range.               Note to give two variable names when using this function.</p> Source code in <code>postbp/tessellation.py</code> <pre><code>def create_hexagons_nodes(boundaryShp, offset_x=0, offset_y=0, **kwargs):\n    \"\"\"Creat geodataframe of hexagonal patches and the nodes (centroids) of the hexagons of defined size and range.\n       Hexagon size can be defined in area, side length, or long diameter. Must input one parameter out of the three options.\n    Args:\n        boundaryShp (GeoDataFrame): the geodataframe defines the range covered by the hexagonal patches\n        area (float, OPTIONAL): define the size of each hexagon by area in square meters\n        side (float, OPTIONAL): define the size of each hexagon by side length in meter\n        diameter (float, OPTIONAL): define the size of each hexagon by long diameter in meter\n        offset_x (fraction, OPTIONAL): defines the horizontal offset for hexagons as a fraction of the length of the hexagon's long diagonal. Can be positive or negative.\n        offset_y (fraction, OPTIONAL): defines the vertical offset for hexagons as a fraction of the length of the hexagon's long diagonal. Can be positive or negative.\n    Returns:\n        GeoDataFrame: return geodataframes of hexagons and nodes of the defined size and covering the defined range.\n                      Note to give two variable names when using this function.\n    \"\"\"    \n    if 'area' in kwargs:\n        area = kwargs['area']\n\n    elif \"side\" in kwargs:\n        area = kwargs[\"side\"]**2*3/2*math.sqrt(3)\n\n    elif \"diameter\" in kwargs:\n        area = kwargs[\"diameter\"]**2*3/8*math.sqrt(3)\n\n    else:\n        print('Please define a value using one of the following parameters: area, side, or diameter of the intended hexagonal patches.')\n\n    myCRS = boundaryShp.crs\n    xmin,ymin,xmax,ymax =  boundaryShp.total_bounds\n    nodes = _create_hexnodes(area, xmin, ymin, xmax, ymax, offset_x, offset_y)\n    hexagons = [_create_hexgrids(area, node[0], node[1]) for node in nodes]\n\n    nodes = [Point(node) for node in nodes]\n    nodes = gpd.GeoDataFrame({'geometry': nodes})\n    nodes['Node_ID'] = nodes.index + 1\n    nodes.crs = myCRS\n    hexagons = gpd.GeoDataFrame({'geometry':hexagons})\n    hexagons['Node_ID'] = hexagons.index + 1\n    hexagons.crs = myCRS\n\n    return hexagons, nodes\n</code></pre>"},{"location":"tessellation/#postbp.tessellation.nodes_from_hexagons","title":"<code>nodes_from_hexagons(hexagons)</code>","text":"<p>Generate nodes geometry from hexagons</p> <p>Parameters:</p> Name Type Description Default <code>hexagons</code> <code>GeoDataFrame</code> <p>geometry and ID of hexagonal patches</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>return nodes geometry with ID attributes same as the hexagons.</p> Source code in <code>postbp/tessellation.py</code> <pre><code>def nodes_from_hexagons(hexagons):\n    \"\"\"Generate nodes geometry from hexagons\n\n    Args:\n        hexagons (GeoDataFrame): geometry and ID of hexagonal patches\n\n    Returns:\n        GeoDataFrame: return nodes geometry with ID attributes same as the hexagons.\n    \"\"\"    \n    nodes = hexagons.copy()\n    nodes['centroid'] = nodes.geometry.centroid\n    nodes.drop(labels='geometry', axis=1, inplace=True)\n    nodes.rename(columns={'centroid':'geometry'}, inplace=True)\n    nodes = nodes.set_geometry('geometry')\n    return nodes\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use postbp in a project:</p> <pre><code>import postbp\n</code></pre> <p>To load FGM outputs:</p> <pre><code>fireshp = postbp.read_fireshp('testDataset_FF.shp')\nSRID = fireshp.crs # record spatial reference of fire shapefile\nignition = postbp.read_pointcsv('testDataset_Statistics.csv', SRID, x_col='x_coord', y_col='y_coord')\nfireshpDaily = postbp.read_fireshp('testDataset_DFF.shp', daily=True)\n</code></pre> <p>To generate hexagonal patches:</p> <pre><code>hexagons, nodes = postbp.create_hexagons_nodes(area=[your_choice_in_m2], boundaryShp=fireshp)\nhexagons = postbp.create_hexagons(area=[your_choice_in_m2], boundaryShp=fireshp)\nnodes = postbp.nodes_from_hexagons(hexagons)\n</code></pre> <p>To get ignition probability</p> <pre><code>ignProb = postbp.generate_ign_prob(ignition, hexagons, iterations=[number_of_iterations_in_your_model])\n</code></pre> <p>To get burn probability </p> <pre><code>burnProb = postbp.generate_burn_prob(fireshp, hexagons, iterations=[number_of_iterations_in_your_model])\n</code></pre> <p>To generate fire vectors:</p> <pre><code>fire_vectors = postbp.generate_fire_vectors(fireshp, ignition, hexagons)\npij = postbp.pij_from_vectors(fire_vectors, iterations=16000)\npij_shp = postbp.pij_to_shp(pij, nodes)\n</code></pre> <p>To generate daily fire vectors:</p> <pre><code>fire_vectors_daily = postbp.generate_daily_vectors(fireshpDaily, ignition, hexagons)\nfire_vectors_w_angles = postbp.calc_angles(fire_vectors_daily, nodes)\ndaily_vectors_150 = postbp.select_angle(fire_vectors_w_angles, alpha=150)\ndaily_vectors_60 = postbp.select_angle(fire_vectors_w_angles, alpha=60)\npij_daily_150 = postbp.pij_from_vectors(daily_vectors_150, iterations=16000)\npij_daily_60 = postbp.pij_from_vectors(daily_vectors_60, iterations=16000)\npij_daily_150_shp = postbp.pij_to_shp(pij_daily_150, nodes)\npij_daily_60_shp = postbp.pij_to_shp(pij_daily_60, nodes)\n</code></pre> <p>To generate SSR:</p> <pre><code>fireSSR = postbp.generate_ssr(fire_vectors, hexagons)\n</code></pre> <p>To plot fire rose:</p> <p><code>fireRose = postbp.generate_fire_rose(pij, nodes) postbp.plot_rose(fireRose, column='len', save=False)</code></p>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre># from ipyleaflet import Map\n# m = Map(center=(), zoom=3)\n# m.add_basemap()\n# m.add()\n</pre> # from ipyleaflet import Map # m = Map(center=(), zoom=3) # m.add_basemap() # m.add()"}]}